/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { EventData, PastEventOptions } from "web3-eth-contract";

export interface ISuperTokenContract
  extends Truffle.Contract<ISuperTokenInstance> {
  "new"(meta?: Truffle.TransactionDetails): Promise<ISuperTokenInstance>;
}

export interface AgreementCreated {
  name: "AgreementCreated";
  args: {
    agreementClass: string;
    id: string;
    data: string[];
    0: string;
    1: string;
    2: string[];
  };
}

export interface AgreementLiquidated {
  name: "AgreementLiquidated";
  args: {
    agreementClass: string;
    id: string;
    penaltyAccount: string;
    rewardAccount: string;
    rewardAmount: BN;
    0: string;
    1: string;
    2: string;
    3: string;
    4: BN;
  };
}

export interface AgreementLiquidatedBy {
  name: "AgreementLiquidatedBy";
  args: {
    liquidatorAccount: string;
    agreementClass: string;
    id: string;
    penaltyAccount: string;
    bondAccount: string;
    rewardAmount: BN;
    bailoutAmount: BN;
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: BN;
    6: BN;
  };
}

export interface AgreementLiquidatedV2 {
  name: "AgreementLiquidatedV2";
  args: {
    agreementClass: string;
    id: string;
    liquidatorAccount: string;
    targetAccount: string;
    rewardAmountReceiver: string;
    rewardAmount: BN;
    targetAccountBalanceDelta: BN;
    liquidationTypeData: string;
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
    5: BN;
    6: BN;
    7: string;
  };
}

export interface AgreementStateUpdated {
  name: "AgreementStateUpdated";
  args: {
    agreementClass: string;
    account: string;
    slotId: BN;
    0: string;
    1: string;
    2: BN;
  };
}

export interface AgreementTerminated {
  name: "AgreementTerminated";
  args: {
    agreementClass: string;
    id: string;
    0: string;
    1: string;
  };
}

export interface AgreementUpdated {
  name: "AgreementUpdated";
  args: {
    agreementClass: string;
    id: string;
    data: string[];
    0: string;
    1: string;
    2: string[];
  };
}

export interface Approval {
  name: "Approval";
  args: {
    owner: string;
    spender: string;
    value: BN;
    0: string;
    1: string;
    2: BN;
  };
}

export interface AuthorizedOperator {
  name: "AuthorizedOperator";
  args: {
    operator: string;
    tokenHolder: string;
    0: string;
    1: string;
  };
}

export interface Bailout {
  name: "Bailout";
  args: {
    bailoutAccount: string;
    bailoutAmount: BN;
    0: string;
    1: BN;
  };
}

export interface Burned {
  name: "Burned";
  args: {
    operator: string;
    from: string;
    amount: BN;
    data: string;
    operatorData: string;
    0: string;
    1: string;
    2: BN;
    3: string;
    4: string;
  };
}

export interface Minted {
  name: "Minted";
  args: {
    operator: string;
    to: string;
    amount: BN;
    data: string;
    operatorData: string;
    0: string;
    1: string;
    2: BN;
    3: string;
    4: string;
  };
}

export interface RevokedOperator {
  name: "RevokedOperator";
  args: {
    operator: string;
    tokenHolder: string;
    0: string;
    1: string;
  };
}

export interface Sent {
  name: "Sent";
  args: {
    operator: string;
    from: string;
    to: string;
    amount: BN;
    data: string;
    operatorData: string;
    0: string;
    1: string;
    2: string;
    3: BN;
    4: string;
    5: string;
  };
}

export interface TokenDowngraded {
  name: "TokenDowngraded";
  args: {
    account: string;
    amount: BN;
    0: string;
    1: BN;
  };
}

export interface TokenUpgraded {
  name: "TokenUpgraded";
  args: {
    account: string;
    amount: BN;
    0: string;
    1: BN;
  };
}

export interface Transfer {
  name: "Transfer";
  args: {
    from: string;
    to: string;
    value: BN;
    0: string;
    1: string;
    2: BN;
  };
}

type AllEvents =
  | AgreementCreated
  | AgreementLiquidated
  | AgreementLiquidatedBy
  | AgreementLiquidatedV2
  | AgreementStateUpdated
  | AgreementTerminated
  | AgreementUpdated
  | Approval
  | AuthorizedOperator
  | Bailout
  | Burned
  | Minted
  | RevokedOperator
  | Sent
  | TokenDowngraded
  | TokenUpgraded
  | Transfer;

export interface ISuperTokenInstance extends Truffle.ContractInstance {
  /**
   * Create a new agreement
   * @param data Agreement data
   * @param id Agreement ID
   */
  createAgreement: {
    (
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * An active agreement is one that has state for the account
   * Get a list of agreements that is active for the account
   * @param account Account to query
   */
  getAccountActiveAgreements(
    account: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<string[]>;

  /**
   * Get data of the agreement
   * @param agreementClass Contract address of the agreement
   * @param id Agreement ID
   */
  getAgreementData(
    agreementClass: string,
    id: string,
    dataLength: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<string[]>;

  /**
   * Get data of the slot of the state of an agreement
   * @param account Account to query
   * @param agreementClass Contract address of the agreement
   * @param dataLength length of the state data
   * @param slotId slot id of the state
   */
  getAgreementStateSlot(
    agreementClass: string,
    account: string,
    slotId: number | BN | string,
    dataLength: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<string[]>;

  /**
   * Get superfluid host contract address
   */
  getHost(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * A critical account is when availableBalance < 0
   * Check if account is critical
   * @param account The account to check
   * @param timestamp The time we'd like to check if the account is critical (should use future)
   */
  isAccountCritical(
    account: string,
    timestamp: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * A critical account is when availableBalance < 0
   * Check if account is critical now (current host.getNow())
   * @param account The account to check
   */
  isAccountCriticalNow(
    account: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance
   * Check if account is solvent
   * @param account The account to check
   * @param timestamp The time we'd like to check if the account is solvent (should use future)
   */
  isAccountSolvent(
    account: string,
    timestamp: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance
   * Check if account is solvent now
   * @param account The account to check
   */
  isAccountSolventNow(
    account: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * Make liquidation payouts (v2)
   * @param id Agreement ID
   * @param liquidationTypeData Data regarding the version of the liquidation schema and the type
   * @param liquidatorAccount Address of the executor of the liquidation
   * @param rewardAmount The amount the rewarded account will receive
   * @param targetAccount Account to be liquidated
   * @param targetAccountBalanceDelta The delta amount the target account balance should change by
   * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount
   */
  makeLiquidationPayoutsV2: {
    (
      id: string,
      liquidationTypeData: string,
      liquidatorAccount: string,
      useDefaultRewardAccount: boolean,
      targetAccount: string,
      rewardAmount: number | BN | string,
      targetAccountBalanceDelta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      id: string,
      liquidationTypeData: string,
      liquidatorAccount: string,
      useDefaultRewardAccount: boolean,
      targetAccount: string,
      rewardAmount: number | BN | string,
      targetAccountBalanceDelta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      id: string,
      liquidationTypeData: string,
      liquidatorAccount: string,
      useDefaultRewardAccount: boolean,
      targetAccount: string,
      rewardAmount: number | BN | string,
      targetAccountBalanceDelta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      id: string,
      liquidationTypeData: string,
      liquidatorAccount: string,
      useDefaultRewardAccount: boolean,
      targetAccount: string,
      rewardAmount: number | BN | string,
      targetAccountBalanceDelta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Calculate the real balance of a user, taking in consideration all agreements of the account
   * @param account for the query
   * @param timestamp Time of balance
   */
  realtimeBalanceOf(
    account: string,
    timestamp: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<{ 0: BN; 1: BN; 2: BN }>;

  /**
   * realtimeBalanceOf with timestamp equals to block timestamp
   * Calculate the realtime balance given the current host.getNow() value
   * @param account for the query
   */
  realtimeBalanceOfNow(
    account: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<{ 0: BN; 1: BN; 2: BN; 3: BN }>;

  /**
   * The agreement needs to make sure that the balance delta is balanced afterwards
   * Settle balance from an account by the agreement
   * @param account Account to query.
   * @param delta Amount of balance delta to be settled
   */
  settleBalance: {
    (
      account: string,
      delta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      delta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      delta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      delta: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Close the agreement
   * @param id Agreement ID
   */
  terminateAgreement: {
    (
      id: string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      id: string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      id: string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      id: string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Create a new agreement
   * @param data Agreement data
   * @param id Agreement ID
   */
  updateAgreementData: {
    (
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      id: string,
      data: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Update agreement state slot
   * @param account Account to be updated
   */
  updateAgreementStateSlot: {
    (
      account: string,
      slotId: number | BN | string,
      slotData: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      slotId: number | BN | string,
      slotData: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      slotId: number | BN | string,
      slotData: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      slotId: number | BN | string,
      slotData: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Initialize the contract
   */
  initialize: {
    (
      underlyingToken: string,
      underlyingDecimals: number | BN | string,
      n: string,
      s: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      underlyingToken: string,
      underlyingDecimals: number | BN | string,
      n: string,
      s: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      underlyingToken: string,
      underlyingDecimals: number | BN | string,
      n: string,
      s: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      underlyingToken: string,
      underlyingDecimals: number | BN | string,
      n: string,
      s: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the name of the token.
   */
  name(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Returns the symbol of the token, usually a shorter version of the name.
   */
  symbol(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called.
   */
  decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  /**
   * See {IERC20-totalSupply}.
   */
  totalSupply(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  /**
   * Returns the amount of tokens owned by an account (`owner`).
   */
  balanceOf(
    account: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<BN>;

  /**
   * Moves `amount` tokens from the caller's account to `recipient`.
   */
  transfer: {
    (
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
    sendTransaction(
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the remaining number of tokens that `spender` will be         allowed to spend on behalf of `owner` through {transferFrom}. This is         zero by default.
   * This value changes when {approve} or {transferFrom} are called.
   */
  allowance(
    owner: string,
    spender: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<BN>;

  /**
   * Sets `amount` as the allowance of `spender` over the caller's tokens.
   */
  approve: {
    (
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
    sendTransaction(
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Moves `amount` tokens from `sender` to `recipient` using the         allowance mechanism. `amount` is then deducted from the caller's         allowance.
   */
  transferFrom: {
    (
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
    sendTransaction(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}.
   */
  increaseAllowance: {
    (
      spender: string,
      addedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      spender: string,
      addedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
    sendTransaction(
      spender: string,
      addedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      spender: string,
      addedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}.
   */
  decreaseAllowance: {
    (
      spender: string,
      subtractedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      spender: string,
      subtractedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
    sendTransaction(
      spender: string,
      subtractedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      spender: string,
      subtractedValue: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the smallest part of the token that is not divisible. This         means all token operations (creation, movement and destruction) must have         amounts that are a multiple of this number.
   */
  granularity(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  /**
   * Moves `amount` tokens from the caller's account to `recipient`.If send or receive hooks are registered for the caller and `recipient`,      the corresponding functions will be called with `data` and empty      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
   */
  send: {
    (
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Destroys `amount` tokens from the caller's account, reducing the total supply and transfers the underlying token to the caller's account. If a send hook is registered for the caller, the corresponding function will be called with `data` and empty `operatorData`. See {IERC777Sender}.
   */
  burn: {
    (
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns true if an account is an operator of `tokenHolder`. Operators can send and burn tokens on behalf of their owners. All accounts are their own operator. See {operatorSend} and {operatorBurn}.
   */
  isOperatorFor(
    operator: string,
    tokenHolder: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * Make an account an operator of the caller. See {isOperatorFor}.
   */
  authorizeOperator: {
    (operator: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Revoke an account's operator status for the caller. See {isOperatorFor} and {defaultOperators}.
   */
  revokeOperator: {
    (operator: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the list of default operators. These accounts are operators for all token holders, even if {authorizeOperator} was never called on them. This list is immutable, but individual holders may revoke these via {revokeOperator}, in which case {isOperatorFor} will return false.
   */
  defaultOperators(txDetails?: Truffle.TransactionDetails): Promise<string[]>;

  /**
   * Moves `amount` tokens from `sender` to `recipient`. The caller must be an operator of `sender`. If send or receive hooks are registered for `sender` and `recipient`, the corresponding functions will be called with `data` and `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
   */
  operatorSend: {
    (
      sender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      sender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Destroys `amount` tokens from `account`, reducing the total supply. The caller must be an operator of `account`. If a send hook is registered for `account`, the corresponding function will be called with `data` and `operatorData`. See {IERC777Sender}.
   */
  operatorBurn: {
    (
      account: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      amount: number | BN | string,
      data: string,
      operatorData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Mint new tokens for the account
   */
  selfMint: {
    (
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Burn existing tokens for the account
   */
  selfBurn: {
    (
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      amount: number | BN | string,
      userData: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Transfer `amount` tokens from the `sender` to `recipient`. If `spender` isn't the same as `sender`, checks if `spender` has allowance to spend tokens of `sender`.
   */
  selfTransferFrom: {
    (
      sender: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      sender: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      sender: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      sender: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Give `spender`, `amount` allowance to spend the tokens of `account`.
   */
  selfApproveFor: {
    (
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Transfer all available balance from `msg.sender` to `recipient`
   */
  transferAll: {
    (recipient: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      recipient: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      recipient: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      recipient: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Return the underlying token contract
   */
  getUnderlyingToken(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Upgrade ERC20 to SuperToken.
   * @param amount Number of tokens to be upgraded (in 18 decimals)
   */
  upgrade: {
    (
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Upgrade ERC20 to SuperToken and transfer immediately
   * @param amount Number of tokens to be upgraded (in 18 decimals)
   * @param data User data for the TokensRecipient callback
   * @param to The account to receive upgraded tokens
   */
  upgradeTo: {
    (
      to: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      to: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      to: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      to: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Downgrade SuperToken to ERC20.It will call transfer to send tokens
   * @param amount Number of tokens to be downgraded
   */
  downgrade: {
    (
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Downgrade SuperToken to ERC20 and transfer immediately
   * @param amount Number of tokens to be downgraded (in 18 decimals)
   * @param to The account to receive downgraded tokens
   */
  downgradeTo: {
    (
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Perform ERC20 approve by host contract.
   * @param account The account owner to be approved.
   * @param amount Number of tokens to be approved.
   * @param spender The spender of account owner's funds.
   */
  operationApprove: {
    (
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Perform ERC20 transferFrom by host contract.
   * @param account The account to spend sender's funds.
   * @param amount Number of tokens to be transferred.
   * @param recipient The recipient of the funds.
   * @param spender The account where the funds is sent from.
   */
  operationTransferFrom: {
    (
      account: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      spender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Perform ERC777 send by host contract.
   * @param amount Number of tokens to be transferred.
   * @param data Arbitrary user inputted data
   * @param recipient The recipient of the funds.
   * @param spender The account where the funds is sent from.
   */
  operationSend: {
    (
      spender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      spender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      spender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      spender: string,
      recipient: string,
      amount: number | BN | string,
      data: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Upgrade ERC20 to SuperToken by host contract.
   * @param account The account to be changed.
   * @param amount Number of tokens to be upgraded (in 18 decimals)
   */
  operationUpgrade: {
    (
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Downgrade ERC20 to SuperToken by host contract.
   * @param account The account to be changed.
   * @param amount Number of tokens to be downgraded (in 18 decimals)
   */
  operationDowngrade: {
    (
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  methods: {
    /**
     * Create a new agreement
     * @param data Agreement data
     * @param id Agreement ID
     */
    createAgreement: {
      (
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * An active agreement is one that has state for the account
     * Get a list of agreements that is active for the account
     * @param account Account to query
     */
    getAccountActiveAgreements(
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string[]>;

    /**
     * Get data of the agreement
     * @param agreementClass Contract address of the agreement
     * @param id Agreement ID
     */
    getAgreementData(
      agreementClass: string,
      id: string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string[]>;

    /**
     * Get data of the slot of the state of an agreement
     * @param account Account to query
     * @param agreementClass Contract address of the agreement
     * @param dataLength length of the state data
     * @param slotId slot id of the state
     */
    getAgreementStateSlot(
      agreementClass: string,
      account: string,
      slotId: number | BN | string,
      dataLength: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string[]>;

    /**
     * Get superfluid host contract address
     */
    getHost(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * A critical account is when availableBalance < 0
     * Check if account is critical
     * @param account The account to check
     * @param timestamp The time we'd like to check if the account is critical (should use future)
     */
    isAccountCritical(
      account: string,
      timestamp: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * A critical account is when availableBalance < 0
     * Check if account is critical now (current host.getNow())
     * @param account The account to check
     */
    isAccountCriticalNow(
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance
     * Check if account is solvent
     * @param account The account to check
     * @param timestamp The time we'd like to check if the account is solvent (should use future)
     */
    isAccountSolvent(
      account: string,
      timestamp: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance
     * Check if account is solvent now
     * @param account The account to check
     */
    isAccountSolventNow(
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * Make liquidation payouts (v2)
     * @param id Agreement ID
     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type
     * @param liquidatorAccount Address of the executor of the liquidation
     * @param rewardAmount The amount the rewarded account will receive
     * @param targetAccount Account to be liquidated
     * @param targetAccountBalanceDelta The delta amount the target account balance should change by
     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount
     */
    makeLiquidationPayoutsV2: {
      (
        id: string,
        liquidationTypeData: string,
        liquidatorAccount: string,
        useDefaultRewardAccount: boolean,
        targetAccount: string,
        rewardAmount: number | BN | string,
        targetAccountBalanceDelta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        id: string,
        liquidationTypeData: string,
        liquidatorAccount: string,
        useDefaultRewardAccount: boolean,
        targetAccount: string,
        rewardAmount: number | BN | string,
        targetAccountBalanceDelta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        id: string,
        liquidationTypeData: string,
        liquidatorAccount: string,
        useDefaultRewardAccount: boolean,
        targetAccount: string,
        rewardAmount: number | BN | string,
        targetAccountBalanceDelta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        id: string,
        liquidationTypeData: string,
        liquidatorAccount: string,
        useDefaultRewardAccount: boolean,
        targetAccount: string,
        rewardAmount: number | BN | string,
        targetAccountBalanceDelta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Calculate the real balance of a user, taking in consideration all agreements of the account
     * @param account for the query
     * @param timestamp Time of balance
     */
    realtimeBalanceOf(
      account: string,
      timestamp: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN; 2: BN }>;

    /**
     * realtimeBalanceOf with timestamp equals to block timestamp
     * Calculate the realtime balance given the current host.getNow() value
     * @param account for the query
     */
    realtimeBalanceOfNow(
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN; 2: BN; 3: BN }>;

    /**
     * The agreement needs to make sure that the balance delta is balanced afterwards
     * Settle balance from an account by the agreement
     * @param account Account to query.
     * @param delta Amount of balance delta to be settled
     */
    settleBalance: {
      (
        account: string,
        delta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        delta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        delta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        delta: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Close the agreement
     * @param id Agreement ID
     */
    terminateAgreement: {
      (
        id: string,
        dataLength: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        id: string,
        dataLength: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        id: string,
        dataLength: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        id: string,
        dataLength: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Create a new agreement
     * @param data Agreement data
     * @param id Agreement ID
     */
    updateAgreementData: {
      (
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        id: string,
        data: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Update agreement state slot
     * @param account Account to be updated
     */
    updateAgreementStateSlot: {
      (
        account: string,
        slotId: number | BN | string,
        slotData: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        slotId: number | BN | string,
        slotData: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        slotId: number | BN | string,
        slotData: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        slotId: number | BN | string,
        slotData: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Initialize the contract
     */
    initialize: {
      (
        underlyingToken: string,
        underlyingDecimals: number | BN | string,
        n: string,
        s: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        underlyingToken: string,
        underlyingDecimals: number | BN | string,
        n: string,
        s: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        underlyingToken: string,
        underlyingDecimals: number | BN | string,
        n: string,
        s: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        underlyingToken: string,
        underlyingDecimals: number | BN | string,
        n: string,
        s: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the name of the token.
     */
    name(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called.
     */
    decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    /**
     * Returns the amount of tokens owned by an account (`owner`).
     */
    balanceOf(
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`.
     */
    transfer: {
      (
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<boolean>;
      sendTransaction(
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the remaining number of tokens that `spender` will be         allowed to spend on behalf of `owner` through {transferFrom}. This is         zero by default.
     * This value changes when {approve} or {transferFrom} are called.
     */
    allowance(
      owner: string,
      spender: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens.
     */
    approve: {
      (
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<boolean>;
      sendTransaction(
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the         allowance mechanism. `amount` is then deducted from the caller's         allowance.
     */
    transferFrom: {
      (
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<boolean>;
      sendTransaction(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}.
     */
    increaseAllowance: {
      (
        spender: string,
        addedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        spender: string,
        addedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<boolean>;
      sendTransaction(
        spender: string,
        addedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        spender: string,
        addedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}.
     */
    decreaseAllowance: {
      (
        spender: string,
        subtractedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        spender: string,
        subtractedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<boolean>;
      sendTransaction(
        spender: string,
        subtractedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        spender: string,
        subtractedValue: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the smallest part of the token that is not divisible. This         means all token operations (creation, movement and destruction) must have         amounts that are a multiple of this number.
     */
    granularity(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`.If send or receive hooks are registered for the caller and `recipient`,      the corresponding functions will be called with `data` and empty      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     */
    send: {
      (
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Destroys `amount` tokens from the caller's account, reducing the total supply and transfers the underlying token to the caller's account. If a send hook is registered for the caller, the corresponding function will be called with `data` and empty `operatorData`. See {IERC777Sender}.
     */
    burn: {
      (
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns true if an account is an operator of `tokenHolder`. Operators can send and burn tokens on behalf of their owners. All accounts are their own operator. See {operatorSend} and {operatorBurn}.
     */
    isOperatorFor(
      operator: string,
      tokenHolder: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * Make an account an operator of the caller. See {isOperatorFor}.
     */
    authorizeOperator: {
      (operator: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Revoke an account's operator status for the caller. See {isOperatorFor} and {defaultOperators}.
     */
    revokeOperator: {
      (operator: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the list of default operators. These accounts are operators for all token holders, even if {authorizeOperator} was never called on them. This list is immutable, but individual holders may revoke these via {revokeOperator}, in which case {isOperatorFor} will return false.
     */
    defaultOperators(txDetails?: Truffle.TransactionDetails): Promise<string[]>;

    /**
     * Moves `amount` tokens from `sender` to `recipient`. The caller must be an operator of `sender`. If send or receive hooks are registered for `sender` and `recipient`, the corresponding functions will be called with `data` and `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     */
    operatorSend: {
      (
        sender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        sender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Destroys `amount` tokens from `account`, reducing the total supply. The caller must be an operator of `account`. If a send hook is registered for `account`, the corresponding function will be called with `data` and `operatorData`. See {IERC777Sender}.
     */
    operatorBurn: {
      (
        account: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        amount: number | BN | string,
        data: string,
        operatorData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Mint new tokens for the account
     */
    selfMint: {
      (
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Burn existing tokens for the account
     */
    selfBurn: {
      (
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        amount: number | BN | string,
        userData: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Transfer `amount` tokens from the `sender` to `recipient`. If `spender` isn't the same as `sender`, checks if `spender` has allowance to spend tokens of `sender`.
     */
    selfTransferFrom: {
      (
        sender: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        sender: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        sender: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        sender: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Give `spender`, `amount` allowance to spend the tokens of `account`.
     */
    selfApproveFor: {
      (
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Transfer all available balance from `msg.sender` to `recipient`
     */
    transferAll: {
      (recipient: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        recipient: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        recipient: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        recipient: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Return the underlying token contract
     */
    getUnderlyingToken(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Upgrade ERC20 to SuperToken.
     * @param amount Number of tokens to be upgraded (in 18 decimals)
     */
    upgrade: {
      (
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Upgrade ERC20 to SuperToken and transfer immediately
     * @param amount Number of tokens to be upgraded (in 18 decimals)
     * @param data User data for the TokensRecipient callback
     * @param to The account to receive upgraded tokens
     */
    upgradeTo: {
      (
        to: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        to: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        to: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        to: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Downgrade SuperToken to ERC20.It will call transfer to send tokens
     * @param amount Number of tokens to be downgraded
     */
    downgrade: {
      (
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Downgrade SuperToken to ERC20 and transfer immediately
     * @param amount Number of tokens to be downgraded (in 18 decimals)
     * @param to The account to receive downgraded tokens
     */
    downgradeTo: {
      (
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Perform ERC20 approve by host contract.
     * @param account The account owner to be approved.
     * @param amount Number of tokens to be approved.
     * @param spender The spender of account owner's funds.
     */
    operationApprove: {
      (
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Perform ERC20 transferFrom by host contract.
     * @param account The account to spend sender's funds.
     * @param amount Number of tokens to be transferred.
     * @param recipient The recipient of the funds.
     * @param spender The account where the funds is sent from.
     */
    operationTransferFrom: {
      (
        account: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        spender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Perform ERC777 send by host contract.
     * @param amount Number of tokens to be transferred.
     * @param data Arbitrary user inputted data
     * @param recipient The recipient of the funds.
     * @param spender The account where the funds is sent from.
     */
    operationSend: {
      (
        spender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        spender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        spender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        spender: string,
        recipient: string,
        amount: number | BN | string,
        data: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Upgrade ERC20 to SuperToken by host contract.
     * @param account The account to be changed.
     * @param amount Number of tokens to be upgraded (in 18 decimals)
     */
    operationUpgrade: {
      (
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Downgrade ERC20 to SuperToken by host contract.
     * @param account The account to be changed.
     * @param amount Number of tokens to be downgraded (in 18 decimals)
     */
    operationDowngrade: {
      (
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
