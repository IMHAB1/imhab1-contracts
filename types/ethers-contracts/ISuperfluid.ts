/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace ISuperfluid {
  export type ContextStruct = {
    appCallbackLevel: PromiseOrValue<BigNumberish>;
    callType: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    msgSender: PromiseOrValue<string>;
    agreementSelector: PromiseOrValue<BytesLike>;
    userData: PromiseOrValue<BytesLike>;
    appCreditGranted: PromiseOrValue<BigNumberish>;
    appCreditWantedDeprecated: PromiseOrValue<BigNumberish>;
    appCreditUsed: PromiseOrValue<BigNumberish>;
    appAddress: PromiseOrValue<string>;
    appCreditToken: PromiseOrValue<string>;
  };

  export type ContextStructOutput = [
    number,
    number,
    BigNumber,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string
  ] & {
    appCallbackLevel: number;
    callType: number;
    timestamp: BigNumber;
    msgSender: string;
    agreementSelector: string;
    userData: string;
    appCreditGranted: BigNumber;
    appCreditWantedDeprecated: BigNumber;
    appCreditUsed: BigNumber;
    appAddress: string;
    appCreditToken: string;
  };

  export type OperationStruct = {
    operationType: PromiseOrValue<BigNumberish>;
    target: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
  };

  export type OperationStructOutput = [number, string, string] & {
    operationType: number;
    target: string;
    data: string;
  };
}

export interface ISuperfluidInterface extends utils.Interface {
  functions: {
    "getNow()": FunctionFragment;
    "getGovernance()": FunctionFragment;
    "replaceGovernance(address)": FunctionFragment;
    "registerAgreementClass(address)": FunctionFragment;
    "updateAgreementClass(address)": FunctionFragment;
    "isAgreementTypeListed(bytes32)": FunctionFragment;
    "isAgreementClassListed(address)": FunctionFragment;
    "getAgreementClass(bytes32)": FunctionFragment;
    "mapAgreementClasses(uint256)": FunctionFragment;
    "addToAgreementClassesBitmap(uint256,bytes32)": FunctionFragment;
    "removeFromAgreementClassesBitmap(uint256,bytes32)": FunctionFragment;
    "getSuperTokenFactory()": FunctionFragment;
    "getSuperTokenFactoryLogic()": FunctionFragment;
    "updateSuperTokenFactory(address)": FunctionFragment;
    "updateSuperTokenLogic(address)": FunctionFragment;
    "registerApp(uint256)": FunctionFragment;
    "registerAppWithKey(uint256,string)": FunctionFragment;
    "registerAppByFactory(address,uint256)": FunctionFragment;
    "isApp(address)": FunctionFragment;
    "getAppCallbackLevel(address)": FunctionFragment;
    "getAppManifest(address)": FunctionFragment;
    "isAppJailed(address)": FunctionFragment;
    "allowCompositeApp(address)": FunctionFragment;
    "isCompositeAppAllowed(address,address)": FunctionFragment;
    "callAppBeforeCallback(address,bytes,bool,bytes)": FunctionFragment;
    "callAppAfterCallback(address,bytes,bool,bytes)": FunctionFragment;
    "appCallbackPush(bytes,address,uint256,int256,address)": FunctionFragment;
    "appCallbackPop(bytes,int256)": FunctionFragment;
    "ctxUseCredit(bytes,int256)": FunctionFragment;
    "jailApp(bytes,address,uint256)": FunctionFragment;
    "callAgreement(address,bytes,bytes)": FunctionFragment;
    "callAppAction(address,bytes)": FunctionFragment;
    "callAgreementWithContext(address,bytes,bytes,bytes)": FunctionFragment;
    "callAppActionWithContext(address,bytes,bytes)": FunctionFragment;
    "decodeCtx(bytes)": FunctionFragment;
    "isCtxValid(bytes)": FunctionFragment;
    "batchCall((uint32,address,bytes)[])": FunctionFragment;
    "forwardBatchCall((uint32,address,bytes)[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getNow"
      | "getGovernance"
      | "replaceGovernance"
      | "registerAgreementClass"
      | "updateAgreementClass"
      | "isAgreementTypeListed"
      | "isAgreementClassListed"
      | "getAgreementClass"
      | "mapAgreementClasses"
      | "addToAgreementClassesBitmap"
      | "removeFromAgreementClassesBitmap"
      | "getSuperTokenFactory"
      | "getSuperTokenFactoryLogic"
      | "updateSuperTokenFactory"
      | "updateSuperTokenLogic"
      | "registerApp"
      | "registerAppWithKey"
      | "registerAppByFactory"
      | "isApp"
      | "getAppCallbackLevel"
      | "getAppManifest"
      | "isAppJailed"
      | "allowCompositeApp"
      | "isCompositeAppAllowed"
      | "callAppBeforeCallback"
      | "callAppAfterCallback"
      | "appCallbackPush"
      | "appCallbackPop"
      | "ctxUseCredit"
      | "jailApp"
      | "callAgreement"
      | "callAppAction"
      | "callAgreementWithContext"
      | "callAppActionWithContext"
      | "decodeCtx"
      | "isCtxValid"
      | "batchCall"
      | "forwardBatchCall"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "getNow", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getGovernance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "replaceGovernance",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAgreementClass",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAgreementClass",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAgreementTypeListed",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAgreementClassListed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAgreementClass",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "mapAgreementClasses",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "addToAgreementClassesBitmap",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeFromAgreementClassesBitmap",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSuperTokenFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSuperTokenFactoryLogic",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateSuperTokenFactory",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSuperTokenLogic",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerApp",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAppWithKey",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAppByFactory",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isApp",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAppCallbackLevel",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAppManifest",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAppJailed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "allowCompositeApp",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCompositeAppAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "callAppBeforeCallback",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callAppAfterCallback",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "appCallbackPush",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "appCallbackPop",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "ctxUseCredit",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "jailApp",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callAgreement",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callAppAction",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "callAgreementWithContext",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callAppActionWithContext",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "decodeCtx",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCtxValid",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCall",
    values: [ISuperfluid.OperationStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "forwardBatchCall",
    values: [ISuperfluid.OperationStruct[]]
  ): string;

  decodeFunctionResult(functionFragment: "getNow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "replaceGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAgreementClass",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAgreementClass",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAgreementTypeListed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAgreementClassListed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAgreementClass",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mapAgreementClasses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addToAgreementClassesBitmap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeFromAgreementClassesBitmap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSuperTokenFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSuperTokenFactoryLogic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSuperTokenFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSuperTokenLogic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerApp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAppWithKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAppByFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isApp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAppCallbackLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAppManifest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAppJailed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowCompositeApp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCompositeAppAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAppBeforeCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAppAfterCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appCallbackPush",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appCallbackPop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ctxUseCredit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "jailApp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "callAgreement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAppAction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAgreementWithContext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAppActionWithContext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decodeCtx", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isCtxValid", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "batchCall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forwardBatchCall",
    data: BytesLike
  ): Result;

  events: {
    "AgreementClassRegistered(bytes32,address)": EventFragment;
    "AgreementClassUpdated(bytes32,address)": EventFragment;
    "AppRegistered(address)": EventFragment;
    "GovernanceReplaced(address,address)": EventFragment;
    "Jail(address,uint256)": EventFragment;
    "SuperTokenFactoryUpdated(address)": EventFragment;
    "SuperTokenLogicUpdated(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AgreementClassRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AgreementClassUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AppRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GovernanceReplaced"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Jail"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SuperTokenFactoryUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SuperTokenLogicUpdated"): EventFragment;
}

export interface AgreementClassRegisteredEventObject {
  agreementType: string;
  code: string;
}
export type AgreementClassRegisteredEvent = TypedEvent<
  [string, string],
  AgreementClassRegisteredEventObject
>;

export type AgreementClassRegisteredEventFilter =
  TypedEventFilter<AgreementClassRegisteredEvent>;

export interface AgreementClassUpdatedEventObject {
  agreementType: string;
  code: string;
}
export type AgreementClassUpdatedEvent = TypedEvent<
  [string, string],
  AgreementClassUpdatedEventObject
>;

export type AgreementClassUpdatedEventFilter =
  TypedEventFilter<AgreementClassUpdatedEvent>;

export interface AppRegisteredEventObject {
  app: string;
}
export type AppRegisteredEvent = TypedEvent<[string], AppRegisteredEventObject>;

export type AppRegisteredEventFilter = TypedEventFilter<AppRegisteredEvent>;

export interface GovernanceReplacedEventObject {
  oldGov: string;
  newGov: string;
}
export type GovernanceReplacedEvent = TypedEvent<
  [string, string],
  GovernanceReplacedEventObject
>;

export type GovernanceReplacedEventFilter =
  TypedEventFilter<GovernanceReplacedEvent>;

export interface JailEventObject {
  app: string;
  reason: BigNumber;
}
export type JailEvent = TypedEvent<[string, BigNumber], JailEventObject>;

export type JailEventFilter = TypedEventFilter<JailEvent>;

export interface SuperTokenFactoryUpdatedEventObject {
  newFactory: string;
}
export type SuperTokenFactoryUpdatedEvent = TypedEvent<
  [string],
  SuperTokenFactoryUpdatedEventObject
>;

export type SuperTokenFactoryUpdatedEventFilter =
  TypedEventFilter<SuperTokenFactoryUpdatedEvent>;

export interface SuperTokenLogicUpdatedEventObject {
  token: string;
  code: string;
}
export type SuperTokenLogicUpdatedEvent = TypedEvent<
  [string, string],
  SuperTokenLogicUpdatedEventObject
>;

export type SuperTokenLogicUpdatedEventFilter =
  TypedEventFilter<SuperTokenLogicUpdatedEvent>;

export interface ISuperfluid extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ISuperfluidInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    getNow(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Get the current governance address of the Superfluid host
     */
    getGovernance(
      overrides?: CallOverrides
    ): Promise<[string] & { governance: string }>;

    /**
     * Replace the current governance with a new one
     */
    replaceGovernance(
      newGov: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Register a new agreement class to the system
     * @param agreementClassLogic Initial agreement class code
     */
    registerAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update code of an agreement class
     * @param agreementClassLogic New code for the agreement class
     */
    updateAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Check if the agreement type is whitelisted
     */
    isAgreementTypeListed(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { yes: boolean }>;

    /**
     * Check if the agreement class is whitelisted
     */
    isAgreementClassListed(
      agreementClass: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { yes: boolean }>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Get agreement class
     */
    getAgreementClass(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { agreementClass: string }>;

    /**
     * Map list of the agreement classes using a bitmap
     * @param bitmap Agreement class bitmap
     */
    mapAgreementClasses(
      bitmap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { agreementClasses: string[] }>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by adding a agreement class to it
     * @param bitmap Agreement class bitmap
     */
    addToAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { newBitmap: BigNumber }>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by removing a agreement class from it
     * @param bitmap Agreement class bitmap
     */
    removeFromAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { newBitmap: BigNumber }>;

    /**
     * Get the super token factory
     */
    getSuperTokenFactory(
      overrides?: CallOverrides
    ): Promise<[string] & { factory: string }>;

    /**
     * Get the super token factory logic (applicable to upgradable deployment)
     */
    getSuperTokenFactoryLogic(
      overrides?: CallOverrides
    ): Promise<[string] & { logic: string }>;

    /**
     * Update super token factory
     * @param newFactory New factory logic
     */
    updateSuperTokenFactory(
      newFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Refer to ISuperTokenFactory.Upgradability for expected behaviours
     * Update the super token logic to the latest
     */
    updateSuperTokenLogic(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Message sender (must be a contract) declares itself as a super app.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerApp(
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Message sender declares itself as a super app.
     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide On testnets or in dev environment, a placeholder (e.g. empty string) can be used. While the message sender must be the super app itself, the transaction sender (tx.origin) must be the deployer account the registration key was issued for.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.
     */
    registerAppWithKey(
      configWord: PromiseOrValue<BigNumberish>,
      registrationKey: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Message sender (must be a contract) declares app as a super app
     * On mainnet deployments, only factory contracts pre-authorized by governance can use this. See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerAppByFactory(
      app: PromiseOrValue<string>,
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Query if the app is registered
     * @param app Super app address
     */
    isApp(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Query app callbacklevel
     * @param app Super app address
     */
    getAppCallbackLevel(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number] & { appCallbackLevel: number }>;

    /**
     * Get the manifest of the super app
     * @param app Super app address
     */
    getAppManifest(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber] & {
        isSuperApp: boolean;
        isJailed: boolean;
        noopMask: BigNumber;
      }
    >;

    /**
     * Query if the app has been jailed
     * @param app Super app address
     */
    isAppJailed(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isJail: boolean }>;

    /**
     * Whitelist the target app for app composition for the source app (msg.sender)
     * @param targetApp The target super app address
     */
    allowCompositeApp(
      targetApp: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Query if source app is allowed to call the target app as downstream app
     * @param app Super app address
     * @param targetApp The target super app address
     */
    isCompositeAppAllowed(
      app: PromiseOrValue<string>,
      targetApp: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isAppAllowed: boolean }>;

    /**
     * (For agreements) StaticCall the app before callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppBeforeCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * (For agreements) Call the app after callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppAfterCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * (For agreements) Create a new callback stack
     * @param app The super app.
     * @param appCreditGranted App credit granted so far.
     * @param appCreditUsed App credit used so far.
     * @param ctx The current ctx, it will be validated.
     */
    appCallbackPush(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      appCreditGranted: PromiseOrValue<BigNumberish>,
      appCreditUsed: PromiseOrValue<BigNumberish>,
      appCreditToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * (For agreements) Pop from the current app callback stack
     * @param appCreditUsedDelta App credit used by the app.
     * @param ctx The ctx that was pushed before the callback stack.
     */
    appCallbackPop(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * (For agreements) Use app credit.
     * @param appCreditUsedMore See app credit for more details.
     * @param ctx The current ctx, it will be validated.
     */
    ctxUseCredit(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedMore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * (For agreements) Jail the app.
     * @param app The super app.
     * @param reason Jail reason code.
     */
    jailApp(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      reason: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Call agreement function
     * @param agreementClass The agreement address you are calling
     * @param callData The contextual call data with placeholder ctx
     * @param userData Extra user data being sent to the super app callbacks
     */
    callAgreement(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Main use case is calling app action in a batch call via the host
     * Call app action
     * @param callData The contextual call data
     */
    callAppAction(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    callAgreementWithContext(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    callAppActionWithContext(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    decodeCtx(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [ISuperfluid.ContextStructOutput] & {
        context: ISuperfluid.ContextStructOutput;
      }
    >;

    isCtxValid(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    batchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forwardBatchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  getNow(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the current governance address of the Superfluid host
   */
  getGovernance(overrides?: CallOverrides): Promise<string>;

  /**
   * Replace the current governance with a new one
   */
  replaceGovernance(
    newGov: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Register a new agreement class to the system
   * @param agreementClassLogic Initial agreement class code
   */
  registerAgreementClass(
    agreementClassLogic: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update code of an agreement class
   * @param agreementClassLogic New code for the agreement class
   */
  updateAgreementClass(
    agreementClassLogic: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
   * Check if the agreement type is whitelisted
   */
  isAgreementTypeListed(
    agreementType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Check if the agreement class is whitelisted
   */
  isAgreementClassListed(
    agreementClass: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
   * Get agreement class
   */
  getAgreementClass(
    agreementType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Map list of the agreement classes using a bitmap
   * @param bitmap Agreement class bitmap
   */
  mapAgreementClasses(
    bitmap: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
   * Create a new bitmask by adding a agreement class to it
   * @param bitmap Agreement class bitmap
   */
  addToAgreementClassesBitmap(
    bitmap: PromiseOrValue<BigNumberish>,
    agreementType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
   * Create a new bitmask by removing a agreement class from it
   * @param bitmap Agreement class bitmap
   */
  removeFromAgreementClassesBitmap(
    bitmap: PromiseOrValue<BigNumberish>,
    agreementType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the super token factory
   */
  getSuperTokenFactory(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the super token factory logic (applicable to upgradable deployment)
   */
  getSuperTokenFactoryLogic(overrides?: CallOverrides): Promise<string>;

  /**
   * Update super token factory
   * @param newFactory New factory logic
   */
  updateSuperTokenFactory(
    newFactory: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Refer to ISuperTokenFactory.Upgradability for expected behaviours
   * Update the super token logic to the latest
   */
  updateSuperTokenLogic(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Message sender (must be a contract) declares itself as a super app.
   * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
   */
  registerApp(
    configWord: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Message sender declares itself as a super app.
   * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide On testnets or in dev environment, a placeholder (e.g. empty string) can be used. While the message sender must be the super app itself, the transaction sender (tx.origin) must be the deployer account the registration key was issued for.
   * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
   * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.
   */
  registerAppWithKey(
    configWord: PromiseOrValue<BigNumberish>,
    registrationKey: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Message sender (must be a contract) declares app as a super app
   * On mainnet deployments, only factory contracts pre-authorized by governance can use this. See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide
   * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
   */
  registerAppByFactory(
    app: PromiseOrValue<string>,
    configWord: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Query if the app is registered
   * @param app Super app address
   */
  isApp(
    app: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Query app callbacklevel
   * @param app Super app address
   */
  getAppCallbackLevel(
    app: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * Get the manifest of the super app
   * @param app Super app address
   */
  getAppManifest(
    app: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean, BigNumber] & {
      isSuperApp: boolean;
      isJailed: boolean;
      noopMask: BigNumber;
    }
  >;

  /**
   * Query if the app has been jailed
   * @param app Super app address
   */
  isAppJailed(
    app: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Whitelist the target app for app composition for the source app (msg.sender)
   * @param targetApp The target super app address
   */
  allowCompositeApp(
    targetApp: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Query if source app is allowed to call the target app as downstream app
   * @param app Super app address
   * @param targetApp The target super app address
   */
  isCompositeAppAllowed(
    app: PromiseOrValue<string>,
    targetApp: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * (For agreements) StaticCall the app before callback
   * @param app The super app.
   * @param callData The call data sending to the super app.
   * @param ctx Current ctx, it will be validated.
   * @param isTermination Is it a termination callback?
   */
  callAppBeforeCallback(
    app: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    isTermination: PromiseOrValue<boolean>,
    ctx: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * (For agreements) Call the app after callback
   * @param app The super app.
   * @param callData The call data sending to the super app.
   * @param ctx Current ctx, it will be validated.
   * @param isTermination Is it a termination callback?
   */
  callAppAfterCallback(
    app: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    isTermination: PromiseOrValue<boolean>,
    ctx: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * (For agreements) Create a new callback stack
   * @param app The super app.
   * @param appCreditGranted App credit granted so far.
   * @param appCreditUsed App credit used so far.
   * @param ctx The current ctx, it will be validated.
   */
  appCallbackPush(
    ctx: PromiseOrValue<BytesLike>,
    app: PromiseOrValue<string>,
    appCreditGranted: PromiseOrValue<BigNumberish>,
    appCreditUsed: PromiseOrValue<BigNumberish>,
    appCreditToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * (For agreements) Pop from the current app callback stack
   * @param appCreditUsedDelta App credit used by the app.
   * @param ctx The ctx that was pushed before the callback stack.
   */
  appCallbackPop(
    ctx: PromiseOrValue<BytesLike>,
    appCreditUsedDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * (For agreements) Use app credit.
   * @param appCreditUsedMore See app credit for more details.
   * @param ctx The current ctx, it will be validated.
   */
  ctxUseCredit(
    ctx: PromiseOrValue<BytesLike>,
    appCreditUsedMore: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * (For agreements) Jail the app.
   * @param app The super app.
   * @param reason Jail reason code.
   */
  jailApp(
    ctx: PromiseOrValue<BytesLike>,
    app: PromiseOrValue<string>,
    reason: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Call agreement function
   * @param agreementClass The agreement address you are calling
   * @param callData The contextual call data with placeholder ctx
   * @param userData Extra user data being sent to the super app callbacks
   */
  callAgreement(
    agreementClass: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    userData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Main use case is calling app action in a batch call via the host
   * Call app action
   * @param callData The contextual call data
   */
  callAppAction(
    app: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callAgreementWithContext(
    agreementClass: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    userData: PromiseOrValue<BytesLike>,
    ctx: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callAppActionWithContext(
    app: PromiseOrValue<string>,
    callData: PromiseOrValue<BytesLike>,
    ctx: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  decodeCtx(
    ctx: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<ISuperfluid.ContextStructOutput>;

  isCtxValid(
    ctx: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  batchCall(
    operations: ISuperfluid.OperationStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forwardBatchCall(
    operations: ISuperfluid.OperationStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    getNow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the current governance address of the Superfluid host
     */
    getGovernance(overrides?: CallOverrides): Promise<string>;

    /**
     * Replace the current governance with a new one
     */
    replaceGovernance(
      newGov: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Register a new agreement class to the system
     * @param agreementClassLogic Initial agreement class code
     */
    registerAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update code of an agreement class
     * @param agreementClassLogic New code for the agreement class
     */
    updateAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Check if the agreement type is whitelisted
     */
    isAgreementTypeListed(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Check if the agreement class is whitelisted
     */
    isAgreementClassListed(
      agreementClass: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Get agreement class
     */
    getAgreementClass(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Map list of the agreement classes using a bitmap
     * @param bitmap Agreement class bitmap
     */
    mapAgreementClasses(
      bitmap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by adding a agreement class to it
     * @param bitmap Agreement class bitmap
     */
    addToAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by removing a agreement class from it
     * @param bitmap Agreement class bitmap
     */
    removeFromAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the super token factory
     */
    getSuperTokenFactory(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the super token factory logic (applicable to upgradable deployment)
     */
    getSuperTokenFactoryLogic(overrides?: CallOverrides): Promise<string>;

    /**
     * Update super token factory
     * @param newFactory New factory logic
     */
    updateSuperTokenFactory(
      newFactory: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Refer to ISuperTokenFactory.Upgradability for expected behaviours
     * Update the super token logic to the latest
     */
    updateSuperTokenLogic(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Message sender (must be a contract) declares itself as a super app.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerApp(
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Message sender declares itself as a super app.
     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide On testnets or in dev environment, a placeholder (e.g. empty string) can be used. While the message sender must be the super app itself, the transaction sender (tx.origin) must be the deployer account the registration key was issued for.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.
     */
    registerAppWithKey(
      configWord: PromiseOrValue<BigNumberish>,
      registrationKey: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Message sender (must be a contract) declares app as a super app
     * On mainnet deployments, only factory contracts pre-authorized by governance can use this. See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerAppByFactory(
      app: PromiseOrValue<string>,
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Query if the app is registered
     * @param app Super app address
     */
    isApp(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Query app callbacklevel
     * @param app Super app address
     */
    getAppCallbackLevel(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Get the manifest of the super app
     * @param app Super app address
     */
    getAppManifest(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber] & {
        isSuperApp: boolean;
        isJailed: boolean;
        noopMask: BigNumber;
      }
    >;

    /**
     * Query if the app has been jailed
     * @param app Super app address
     */
    isAppJailed(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Whitelist the target app for app composition for the source app (msg.sender)
     * @param targetApp The target super app address
     */
    allowCompositeApp(
      targetApp: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Query if source app is allowed to call the target app as downstream app
     * @param app Super app address
     * @param targetApp The target super app address
     */
    isCompositeAppAllowed(
      app: PromiseOrValue<string>,
      targetApp: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * (For agreements) StaticCall the app before callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppBeforeCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * (For agreements) Call the app after callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppAfterCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * (For agreements) Create a new callback stack
     * @param app The super app.
     * @param appCreditGranted App credit granted so far.
     * @param appCreditUsed App credit used so far.
     * @param ctx The current ctx, it will be validated.
     */
    appCallbackPush(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      appCreditGranted: PromiseOrValue<BigNumberish>,
      appCreditUsed: PromiseOrValue<BigNumberish>,
      appCreditToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * (For agreements) Pop from the current app callback stack
     * @param appCreditUsedDelta App credit used by the app.
     * @param ctx The ctx that was pushed before the callback stack.
     */
    appCallbackPop(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * (For agreements) Use app credit.
     * @param appCreditUsedMore See app credit for more details.
     * @param ctx The current ctx, it will be validated.
     */
    ctxUseCredit(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedMore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * (For agreements) Jail the app.
     * @param app The super app.
     * @param reason Jail reason code.
     */
    jailApp(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      reason: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Call agreement function
     * @param agreementClass The agreement address you are calling
     * @param callData The contextual call data with placeholder ctx
     * @param userData Extra user data being sent to the super app callbacks
     */
    callAgreement(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Main use case is calling app action in a batch call via the host
     * Call app action
     * @param callData The contextual call data
     */
    callAppAction(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    callAgreementWithContext(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string, string] & { newCtx: string; returnedData: string }>;

    callAppActionWithContext(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    decodeCtx(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<ISuperfluid.ContextStructOutput>;

    isCtxValid(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    batchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    forwardBatchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AgreementClassRegistered(bytes32,address)"(
      agreementType?: null,
      code?: null
    ): AgreementClassRegisteredEventFilter;
    AgreementClassRegistered(
      agreementType?: null,
      code?: null
    ): AgreementClassRegisteredEventFilter;

    "AgreementClassUpdated(bytes32,address)"(
      agreementType?: null,
      code?: null
    ): AgreementClassUpdatedEventFilter;
    AgreementClassUpdated(
      agreementType?: null,
      code?: null
    ): AgreementClassUpdatedEventFilter;

    "AppRegistered(address)"(
      app?: PromiseOrValue<string> | null
    ): AppRegisteredEventFilter;
    AppRegistered(
      app?: PromiseOrValue<string> | null
    ): AppRegisteredEventFilter;

    "GovernanceReplaced(address,address)"(
      oldGov?: null,
      newGov?: null
    ): GovernanceReplacedEventFilter;
    GovernanceReplaced(
      oldGov?: null,
      newGov?: null
    ): GovernanceReplacedEventFilter;

    "Jail(address,uint256)"(
      app?: PromiseOrValue<string> | null,
      reason?: null
    ): JailEventFilter;
    Jail(app?: PromiseOrValue<string> | null, reason?: null): JailEventFilter;

    "SuperTokenFactoryUpdated(address)"(
      newFactory?: null
    ): SuperTokenFactoryUpdatedEventFilter;
    SuperTokenFactoryUpdated(
      newFactory?: null
    ): SuperTokenFactoryUpdatedEventFilter;

    "SuperTokenLogicUpdated(address,address)"(
      token?: PromiseOrValue<string> | null,
      code?: null
    ): SuperTokenLogicUpdatedEventFilter;
    SuperTokenLogicUpdated(
      token?: PromiseOrValue<string> | null,
      code?: null
    ): SuperTokenLogicUpdatedEventFilter;
  };

  estimateGas: {
    getNow(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the current governance address of the Superfluid host
     */
    getGovernance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Replace the current governance with a new one
     */
    replaceGovernance(
      newGov: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Register a new agreement class to the system
     * @param agreementClassLogic Initial agreement class code
     */
    registerAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Update code of an agreement class
     * @param agreementClassLogic New code for the agreement class
     */
    updateAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Check if the agreement type is whitelisted
     */
    isAgreementTypeListed(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Check if the agreement class is whitelisted
     */
    isAgreementClassListed(
      agreementClass: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Get agreement class
     */
    getAgreementClass(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Map list of the agreement classes using a bitmap
     * @param bitmap Agreement class bitmap
     */
    mapAgreementClasses(
      bitmap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by adding a agreement class to it
     * @param bitmap Agreement class bitmap
     */
    addToAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by removing a agreement class from it
     * @param bitmap Agreement class bitmap
     */
    removeFromAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the super token factory
     */
    getSuperTokenFactory(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the super token factory logic (applicable to upgradable deployment)
     */
    getSuperTokenFactoryLogic(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Update super token factory
     * @param newFactory New factory logic
     */
    updateSuperTokenFactory(
      newFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Refer to ISuperTokenFactory.Upgradability for expected behaviours
     * Update the super token logic to the latest
     */
    updateSuperTokenLogic(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Message sender (must be a contract) declares itself as a super app.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerApp(
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Message sender declares itself as a super app.
     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide On testnets or in dev environment, a placeholder (e.g. empty string) can be used. While the message sender must be the super app itself, the transaction sender (tx.origin) must be the deployer account the registration key was issued for.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.
     */
    registerAppWithKey(
      configWord: PromiseOrValue<BigNumberish>,
      registrationKey: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Message sender (must be a contract) declares app as a super app
     * On mainnet deployments, only factory contracts pre-authorized by governance can use this. See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerAppByFactory(
      app: PromiseOrValue<string>,
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Query if the app is registered
     * @param app Super app address
     */
    isApp(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Query app callbacklevel
     * @param app Super app address
     */
    getAppCallbackLevel(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the manifest of the super app
     * @param app Super app address
     */
    getAppManifest(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Query if the app has been jailed
     * @param app Super app address
     */
    isAppJailed(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Whitelist the target app for app composition for the source app (msg.sender)
     * @param targetApp The target super app address
     */
    allowCompositeApp(
      targetApp: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Query if source app is allowed to call the target app as downstream app
     * @param app Super app address
     * @param targetApp The target super app address
     */
    isCompositeAppAllowed(
      app: PromiseOrValue<string>,
      targetApp: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * (For agreements) StaticCall the app before callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppBeforeCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * (For agreements) Call the app after callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppAfterCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * (For agreements) Create a new callback stack
     * @param app The super app.
     * @param appCreditGranted App credit granted so far.
     * @param appCreditUsed App credit used so far.
     * @param ctx The current ctx, it will be validated.
     */
    appCallbackPush(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      appCreditGranted: PromiseOrValue<BigNumberish>,
      appCreditUsed: PromiseOrValue<BigNumberish>,
      appCreditToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * (For agreements) Pop from the current app callback stack
     * @param appCreditUsedDelta App credit used by the app.
     * @param ctx The ctx that was pushed before the callback stack.
     */
    appCallbackPop(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * (For agreements) Use app credit.
     * @param appCreditUsedMore See app credit for more details.
     * @param ctx The current ctx, it will be validated.
     */
    ctxUseCredit(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedMore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * (For agreements) Jail the app.
     * @param app The super app.
     * @param reason Jail reason code.
     */
    jailApp(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      reason: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Call agreement function
     * @param agreementClass The agreement address you are calling
     * @param callData The contextual call data with placeholder ctx
     * @param userData Extra user data being sent to the super app callbacks
     */
    callAgreement(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Main use case is calling app action in a batch call via the host
     * Call app action
     * @param callData The contextual call data
     */
    callAppAction(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    callAgreementWithContext(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    callAppActionWithContext(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    decodeCtx(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCtxValid(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forwardBatchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    getNow(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the current governance address of the Superfluid host
     */
    getGovernance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Replace the current governance with a new one
     */
    replaceGovernance(
      newGov: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Register a new agreement class to the system
     * @param agreementClassLogic Initial agreement class code
     */
    registerAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update code of an agreement class
     * @param agreementClassLogic New code for the agreement class
     */
    updateAgreementClass(
      agreementClassLogic: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Check if the agreement type is whitelisted
     */
    isAgreementTypeListed(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Check if the agreement class is whitelisted
     */
    isAgreementClassListed(
      agreementClass: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Get agreement class
     */
    getAgreementClass(
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Map list of the agreement classes using a bitmap
     * @param bitmap Agreement class bitmap
     */
    mapAgreementClasses(
      bitmap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by adding a agreement class to it
     * @param bitmap Agreement class bitmap
     */
    addToAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * agreementType is the keccak256 hash of: "org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>"
     * Create a new bitmask by removing a agreement class from it
     * @param bitmap Agreement class bitmap
     */
    removeFromAgreementClassesBitmap(
      bitmap: PromiseOrValue<BigNumberish>,
      agreementType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the super token factory
     */
    getSuperTokenFactory(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the super token factory logic (applicable to upgradable deployment)
     */
    getSuperTokenFactoryLogic(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Update super token factory
     * @param newFactory New factory logic
     */
    updateSuperTokenFactory(
      newFactory: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Refer to ISuperTokenFactory.Upgradability for expected behaviours
     * Update the super token logic to the latest
     */
    updateSuperTokenLogic(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Message sender (must be a contract) declares itself as a super app.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerApp(
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Message sender declares itself as a super app.
     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide On testnets or in dev environment, a placeholder (e.g. empty string) can be used. While the message sender must be the super app itself, the transaction sender (tx.origin) must be the deployer account the registration key was issued for.
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.
     */
    registerAppWithKey(
      configWord: PromiseOrValue<BigNumberish>,
      registrationKey: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Message sender (must be a contract) declares app as a super app
     * On mainnet deployments, only factory contracts pre-authorized by governance can use this. See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide
     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`
     */
    registerAppByFactory(
      app: PromiseOrValue<string>,
      configWord: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Query if the app is registered
     * @param app Super app address
     */
    isApp(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Query app callbacklevel
     * @param app Super app address
     */
    getAppCallbackLevel(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the manifest of the super app
     * @param app Super app address
     */
    getAppManifest(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Query if the app has been jailed
     * @param app Super app address
     */
    isAppJailed(
      app: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Whitelist the target app for app composition for the source app (msg.sender)
     * @param targetApp The target super app address
     */
    allowCompositeApp(
      targetApp: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Query if source app is allowed to call the target app as downstream app
     * @param app Super app address
     * @param targetApp The target super app address
     */
    isCompositeAppAllowed(
      app: PromiseOrValue<string>,
      targetApp: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) StaticCall the app before callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppBeforeCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) Call the app after callback
     * @param app The super app.
     * @param callData The call data sending to the super app.
     * @param ctx Current ctx, it will be validated.
     * @param isTermination Is it a termination callback?
     */
    callAppAfterCallback(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      isTermination: PromiseOrValue<boolean>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) Create a new callback stack
     * @param app The super app.
     * @param appCreditGranted App credit granted so far.
     * @param appCreditUsed App credit used so far.
     * @param ctx The current ctx, it will be validated.
     */
    appCallbackPush(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      appCreditGranted: PromiseOrValue<BigNumberish>,
      appCreditUsed: PromiseOrValue<BigNumberish>,
      appCreditToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) Pop from the current app callback stack
     * @param appCreditUsedDelta App credit used by the app.
     * @param ctx The ctx that was pushed before the callback stack.
     */
    appCallbackPop(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) Use app credit.
     * @param appCreditUsedMore See app credit for more details.
     * @param ctx The current ctx, it will be validated.
     */
    ctxUseCredit(
      ctx: PromiseOrValue<BytesLike>,
      appCreditUsedMore: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * (For agreements) Jail the app.
     * @param app The super app.
     * @param reason Jail reason code.
     */
    jailApp(
      ctx: PromiseOrValue<BytesLike>,
      app: PromiseOrValue<string>,
      reason: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Call agreement function
     * @param agreementClass The agreement address you are calling
     * @param callData The contextual call data with placeholder ctx
     * @param userData Extra user data being sent to the super app callbacks
     */
    callAgreement(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Main use case is calling app action in a batch call via the host
     * Call app action
     * @param callData The contextual call data
     */
    callAppAction(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    callAgreementWithContext(
      agreementClass: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      userData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    callAppActionWithContext(
      app: PromiseOrValue<string>,
      callData: PromiseOrValue<BytesLike>,
      ctx: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    decodeCtx(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCtxValid(
      ctx: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forwardBatchCall(
      operations: ISuperfluid.OperationStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
